
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>AWS CloudFront &#8212; KX 1.0 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="AWS EBS vs Instance Store" href="aws_ebs_vs_instance_store.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="aws_ebs_vs_instance_store.html" title="AWS EBS vs Instance Store"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">KX 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="aws.html" accesskey="U">Amazon Web Services</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="aws-cloudfront">
<h1>AWS CloudFront<a class="headerlink" href="#aws-cloudfront" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li>CloudFront is a web service that speeds up distribution of static, dynamic web or streaming content to end users.</li>
<li>CloudFront delivers the content through a worldwide network of data centers called edge locations</li>
<li>CloudFront gives businesses and web application developers an easy and cost effective way to distribute content with low latency and high data transfer speeds</li>
<li>CloudFront speeds up the distribution of the content by routing each user request to the edge location that can best serve the content thus providing the lowest latency.</li>
<li>CloudFront dramatically reduces the number of network hops that users’ requests must pass through, which helps improves performance, provide lower latency and higher data transfer rates.</li>
<li>CloudFront is a good choice for distribution of frequently accessed static content that benefits from edge delivery – like popular website images, videos, media files or software downloads</li>
</ul>
<div class="section" id="cloudfront-benefits">
<h2>CloudFront Benefits<a class="headerlink" href="#cloudfront-benefits" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>CloudFront eliminates the expense and complexity of operating a network of cache servers in multiple sites across the internet and eliminates the need to over-provision capacity in order to serve potential spikes in traffic</li>
<li>CloudFront also provides increased reliability and availability because copies of objects are held in multiple edge locations around the world</li>
<li>CloudFront keeps persistent connections with the origin servers so that those files can be fetched from the origin servers as quickly as possible.</li>
<li>CloudFront also uses techniques such as collapsing simultaneous viewer requests at an edge location for the same file into a single request to the origin server reducing the load on the origin</li>
<li>CloudFront integrates with AWS WAF, a web application firewall that helps protect web applications from attacks by allowing rules configured based on IP addresses, HTTP headers, and custom URI strings</li>
</ul>
</div>
<div class="section" id="configuration-content-delivery">
<h2>Configuration &amp; Content Delivery<a class="headerlink" href="#configuration-content-delivery" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">Configuration</p>
<blockquote>
<div><ol class="arabic simple">
<li>Origin servers need to be configured to get the files for distribution. An origin server stores the original, definitive version of the objects and can be a AWS hosted service for e.g. S3, EC2 or an on premise server</li>
<li>Files (also called objects) can be added/uploaded to the Origin servers with public read permissions or permissions restricted to OAI</li>
<li>Create a CloudFront distribution, which tells CloudFront which origin servers to get the files from when users request the files</li>
<li>CloudFront sends the distribution configuration to all the edge locations</li>
<li>Website can be used with the CloudFront provided domain name or a custom alternate domain name</li>
<li>Origin server can be configured to limit access protocols, caching behavior, add headers to the files to add TTL or the expiration time</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Content delivery to Users</p>
<blockquote>
<div><ol class="arabic simple">
<li>When user access the website, file or the object the DNS routes the request to the CloudFront edge location that can best serve the user’s request with the lowest latency</li>
<li>CloudFront returns the object immediately, if the requested object is present in the cache at the Edge location</li>
<li>If the requested object does not exist in the cache at the edge location, CloudFront requests the object from the Origin server and returns it to the user as soon as it starts receiving it</li>
<li>When the object reaches it expiration time, for any new request CloudFront checks with the Origin server for any latest versions, if it has the latest it uses the same object. If the Origin server has the latest version the same is retrieved, served to the user and cached as well</li>
</ol>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="delivery-methods">
<h2>Delivery Methods<a class="headerlink" href="#delivery-methods" title="Permalink to this headline">¶</a></h2>
<div class="section" id="web-distributions">
<h3>Web distributions<a class="headerlink" href="#web-distributions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>supports both static and dynamic content for e.g. html, css, js, images etc using HTTP or HTTPS.</li>
<li>supports multimedia content on demand using progressive download and Apple HTTP Live Streaming (HLS).</li>
<li>supports a live event, such as a meeting, conference, or concert, in real time. For live streaming, distribution can be created automatically using an AWS CloudFormation stack.</li>
<li>origin servers can be either an Amazon S3 bucket or an HTTP server, for e.g., a web server or an AWS ELB etc</li>
</ul>
</div>
<div class="section" id="rmtp-distributions">
<h3>RMTP distributions<a class="headerlink" href="#rmtp-distributions" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">supports streaming of media files using Adobe Media Server and the Adobe Real-Time Messaging Protocol (RTMP)</p>
</li>
<li><p class="first">must use an S3 bucket as the origin.</p>
</li>
<li><p class="first">To stream media files using CloudFront, two types of files are needed</p>
<blockquote>
<div><ul class="simple">
<li>Media files</li>
<li>Media player for e.g. JW Player, Flowplayer, or Adobe flash</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">End users view media files using the media player that is provided; not the locally installed on the computer of the device</p>
</li>
<li><p class="first">When an end user streams the media file, the media player begins to play the file content while the file is still being downloaded from CloudFront.</p>
</li>
<li><p class="first">Media file is not stored locally on the end user’s system.</p>
</li>
<li><p class="first">Two CloudFront distributions are required, Web distribution for media Player and RMTP distribution for media files</p>
</li>
<li><p class="first">Media player and Media files can be stored in same origin S3 bucket or different buckets</p>
</li>
</ul>
</div>
<div class="section" id="origin">
<h3>Origin<a class="headerlink" href="#origin" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Each origin is either an S3 bucket or an HTTP server, for e.g., a web server, which stores the original content</li>
<li>For HTTP server as the origin, the domain name of the resource needs to be mapped and files must be publicly readable</li>
<li>For S3 bucket, use the bucket url or the static website endpoint url and the files either need to be publicly readable or secured using OAI</li>
<li>Origin restrict access, for S3 only, can be configured using Origin Access Identity to prevent direct access to the S3 objects</li>
<li>Distribution can have multiple origins for each bucket with one or more cache behaviors that route requests to each origin. Path pattern in a cache behavior determines which requests are routed to the origin (S3 bucket) that is associated with that cache behavior</li>
</ul>
</div>
<div class="section" id="cache-behavior">
<h3>Cache Behavior<a class="headerlink" href="#cache-behavior" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Cache behavior allows you to define</p>
<blockquote>
<div><ul class="simple">
<li>Path patterns to apply for the request. A default (*) pattern is created and multiple cache distributions can be added with patterns to take priority over the default path</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="viewer-protocol-policy">
<h3>Viewer Protocol Policy<a class="headerlink" href="#viewer-protocol-policy" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Viewer Protocol policy can be configured to define the access protocol allowed. Can be either HTTP and HTTPS, or HTTPS only or HTTP redirected to HTTPS</li>
</ul>
</div>
<div class="section" id="https-connection">
<h3>HTTPS Connection<a class="headerlink" href="#https-connection" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Between CloudFront &amp; Viewers, cache distribution can be configured to either allow HTTP or HTTPS requests, or use HTTPS only, or redirect all HTTP request to HTTPS</p>
</li>
<li><p class="first">Between CloudFront &amp; Origin, cache distribution can be configured to require that CloudFront fetches objects from the origin by using HTTPS or CloudFront uses the protocol that the viewer used to request the objects.</p>
</li>
<li><p class="first">For S3 as origin,</p>
<blockquote>
<div><ul class="simple">
<li>for website, the protocol has to be HTTP as HTTPS is not supported</li>
<li>for S3 bucket, the default Origin protocol policy is Match Viewer and cannot be changed. So When CloudFront is configured to require HTTPS between the viewer and CloudFront, it automatically uses HTTPS to communicate with S3.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">CloudFront can also be configured to work with HTTPS for alternate domain names by using:-</p>
<blockquote>
<div><ul>
<li><p class="first">Serving HTTPS Requests Using Dedicated IP Addresses</p>
<blockquote>
<div><ul class="simple">
<li>CloudFront associates the alternate domain name with a dedicated IP address, and the certificate is associated with the IP address. when a request is received from a DNS server for the IP address,</li>
<li>CloudFront uses the IP address to identify the distribution and the SSL/TLS certificate to return to the viewer</li>
<li>This method works for every HTTPS request, regardless of the browser or other viewer that the user is using.</li>
<li>Additional monthly charge (of about $600/month) is incurred for using dedicated IP address</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Serving HTTPS Requests Using SNI</p>
<blockquote>
<div><ul class="simple">
<li>SNI custom SSL relies on the SNI extension of the TLS protocol, which allows multiple domains to be served over the same IP address by including the hostname, viewers are trying to connect to</li>
<li>With SNI method, CloudFront associates an IP address with the alternate domain name, but the IP address is not dedicated</li>
<li>CloudFront can’t determine, based on the IP address, which domain the request is for as the IP address is not dedicated</li>
<li>Browsers that support SNI automatically gets the domain name from the request URL &amp; adds it to a new field in the request header.</li>
<li>When CloudFront receives an HTTPS request from a browser that supports SNI, it finds the domain name in the request header and responds to the request with the applicable SSL/TLS certificate.</li>
<li>Viewer and CloudFront perform SSL negotiation, and CloudFront returns the requested content to the viewer.</li>
<li>Older browsers do not support it</li>
<li>SNI Custom SSL is available at no additional cost beyond standard CloudFront data transfer and request fees</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">For End-to-End HTTPS connections certificate needs to be applied both between the Viewers and CloudFront &amp; CloudFront and Origin, with the following requirements</p>
<blockquote>
<div><ul>
<li><p class="first"><strong>HTTPS between viewers and CloudFront</strong></p>
<blockquote>
<div><ul class="simple">
<li>Certificate that was issued by a trusted certificate authority (CA) such as Comodo, DigiCert, or Symantec;</li>
<li>Certificate provided by AWS Certificate Manager (ACM);</li>
<li>Self-signed certificate.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>HTTPS between CloudFront and a custom origin</strong></p>
<blockquote>
<div><ul class="simple">
<li>If the origin is not an ELB load balancer, the certificate must be issued by a trusted CA such as Comodo, DigiCert, or Symantec.</li>
<li>For ELB load balancer, certificate provided by ACM can be used</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="allowed-http-methods">
<h3>Allowed HTTP methods<a class="headerlink" href="#allowed-http-methods" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>CloudFront supports GET, HEAD, OPTIONS, PUT, POST, PATCH, DELETE to get, add, update, and delete objects, and to get object headers.</li>
<li>GET, HEAD, OPTIONS methods to use CloudFront only to get objects, object headers or retrieve a list of the options supported from your origin</li>
<li>POST, PUT operations can also be performed for e.g. submitting data from a web form, which are directly proxied back to the Origin server</li>
<li>CloudFront only caches responses to GET and HEAD requests and, optionally, OPTIONS requests. CloudFront does not cache responses to PUT, POST, PATCH, DELETE request methods and these requests are directed to the origin</li>
<li>PUT, POST http methods also help for accelerated content uploads, as these operations will be sent to the origin e.g. S3 via the CloudFront edge location, improving efficiency, reducing latency, and allowing the application to benefit from the monitored, persistent connections that CloudFront maintains from the edge locations to the origin servers.</li>
</ul>
</div>
<div class="section" id="improving-cloudfront-edge-caches">
<h3>Improving CloudFront Edge Caches<a class="headerlink" href="#improving-cloudfront-edge-caches" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Control the cache max-age</p>
<blockquote>
<div><ul class="simple">
<li>To increase the cache hit ratio, origin can be configured to add a Cache-Control max-age directive to the objects.</li>
<li>Longer the interval less frequently it would be retrieved from the origin</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Caching Based on Query String Parameters</p>
<blockquote>
<div><ul>
<li><p class="first">For Web distributions, CloudFront can be configured to cache based on the query parameters</p>
</li>
<li><p class="first">Caching performance can be improved by</p>
<blockquote>
<div><ul class="simple">
<li>Configure CloudFront to forward only the query strings for which your origin will return unique objects.</li>
<li>Using the same case for the parameters values for e.g. parameter value A or a, CloudFront would cache the same request twice even if the response or object returned is identical</li>
<li>Using the same parameter order for e.g. for request a=x&amp;b=y and b=y&amp;a=x, CloudFront would cache the same request twice even thought the response or object returned is identical</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">For RTMP distributions, when CloudFront requests an object from the origin server, it removes any query string parameters.</p>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Caching Based on Cookie Values</p>
<blockquote>
<div><ul>
<li><p class="first">For Web distributions, CloudFront can be configured to cache based on cookie values.</p>
</li>
<li><p class="first">By default, it doesn’t consider cookies while caching on edge locations</p>
</li>
<li><p class="first">Caching performance can be improved by</p>
<blockquote>
<div><ul class="simple">
<li>Configure CloudFront to forward only specified cookies instead of forwarding all cookies for e.g. if the request has 2 cookies with 3 possible values, CloudFront would cache all possible combinations even if the response takes into account a single cookie</li>
<li>Cookie names and values are both case sensitive so better to stick with the same case</li>
<li>Create separate cache behaviors for static and dynamic content, and configure CloudFront to forward cookies to the origin only for dynamic content for e.g. for css files, the cookies do not make sense as the object does not change with the cookie value</li>
<li>If possible, create separate cache behaviors for dynamic content for which cookie values are unique for each user (such as a user ID) and dynamic content that varies based on a smaller number of unique values reducing the number of combinations</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">For RTMP distributions, CloudFront cannot be configured to process cookies. When CloudFront requests an object from the origin server, it removes any cookies before forwarding the request to your origin. If your origin returns any cookies along with the object, CloudFront removes them before returning the object to the viewer.</p>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Caching Based on Request Headers</p>
<blockquote>
<div><ul>
<li><p class="first">CloudFront can be configured to cache based on request headers</p>
</li>
<li><p class="first">By default, CloudFront doesn’t consider headers when caching your objects in edge locations.</p>
</li>
<li><p class="first">CloudFront configured to cache based on request headers, does not change the headers that CloudFront forwards, only whether CloudFront caches objects based on the header values.</p>
</li>
<li><p class="first">Caching performance can be improved by</p>
<blockquote>
<div><ul class="simple">
<li>Configure CloudFront to forward and cache based only specified headers instead of forwarding and caching based on all headers.</li>
<li>Try to avoid caching based on request headers that have large numbers of unique values.</li>
<li>CloudFront configured to forward all headers to your origin, CloudFront doesn’t cache the objects associated with this cache behavior. Instead, it sends every request to the origin</li>
<li>CloudFront caches based on header values, it doesn’t consider the case of the header name, but considers the case of the header value</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">For RTMP distributions, CloudFront cannot be configured to cache based on header values.</p>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="object-caching-expiration">
<h3>Object Caching &amp; Expiration<a class="headerlink" href="#object-caching-expiration" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Object expiration determines how long the objects stay in a CloudFront cache before it fetches it again from Origin</p>
</li>
<li><p class="first">Low expiration time helps serve content that changes frequently and high expiration time helps improve performance and reduce load on the origin</p>
</li>
<li><p class="first">After expiration time, CloudFront checks if it still has the latest version</p>
<blockquote>
<div><ul class="simple">
<li>if the cache already has the latest version, the origin returns a 304 status code (Not Modified).</li>
<li>if the CloudFront cache does not have the latest version, the origin returns a 200 status code (OK) and the latest version of the object</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">If an object in an edge location isn’t frequently requested, CloudFront might evict the object, remove the object before its expiration date, to make room for objects that have been requested more recently.</p>
</li>
<li><p class="first">By default, each object automatically expires after 24 hours</p>
</li>
<li><p class="first">For Web distributions, the default behavior can be changed by</p>
<blockquote>
<div><ul class="simple">
<li>for the entire path pattern, cache behavior can be configured by setting of Minimum TTL, Maximum TTL and Default TTL values</li>
<li>for individual objects, origin can be configured to add a Cache-Control max-age or Cache-Control s-maxage directive, or an Expires header field to the object.</li>
<li>AWS recommends using Cache-Control max-age directive over Expires header to control object caching behavior</li>
<li>CloudFront uses only the value of Cache-Control max-age, if both the Cache-Control max-age directive and Expires header are specified</li>
<li>HTTP Cache-Control or Pragma header fields in a GET request from a viewer can’t be used to force CloudFront to go back to the origin server for the object</li>
<li>By default, when the origin returns an HTTP 4xx or 5xx status code, CloudFront caches these error responses for five minutes and then submits the next request for the object to the origin to see whether the requested object is available and the problem has been resolved</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">For RTMP distributions</p>
<blockquote>
<div><ul class="simple">
<li>Cache-Control or Expires headers can be added to objects to change the amount of time that CloudFront keeps objects in edge caches before it forwards another request to the origin.</li>
<li>Minimum duration is 3600 seconds (one hour). If you specify a lower value, CloudFront uses 3600 seconds.</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="restrict-viewer-access">
<h2>Restrict viewer access<a class="headerlink" href="#restrict-viewer-access" title="Permalink to this headline">¶</a></h2>
<div class="section" id="serving-private-content">
<h3>Serving Private Content<a class="headerlink" href="#serving-private-content" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">To securely serve private content using CloudFront</p>
<blockquote>
<div><ul>
<li><p class="first">Require the users to access the private content by using special CloudFront signed URLs or signed cookies with following restrictions</p>
<blockquote>
<div><ul class="simple">
<li>an end date and time, after which the URL is no longer valid</li>
<li>start date time, when the URL becomes valid</li>
<li>ip address or range of addresses to access the URLs</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Require that users access the S3 content only using CloudFront URLs, not S3 URLs. Requiring CloudFront URLs isn’t required, but recommended to prevent users from bypassing the restrictions specified in signed URLs or signed cookies.</p>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Signed URLs or Signed Cookies can used with CloudFront using HTTP server as an origin. It requires the content to be publicly accessible and care should be taken to not share the direct URL of the content</p>
</li>
<li><p class="first">Restriction for Origin can be applied by</p>
<blockquote>
<div><ul class="simple">
<li>For S3, using Origin Access Identity to grant only CloudFront access using Bucket policies or Object ACL, to the content and removing any other access permissions</li>
<li>For HTTP server, custom header can be added by CloudFront which can be used at Origin to verify the request has come from CloudFront</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Trusted Signer</p>
<blockquote>
<div><ul class="simple">
<li>To create signed URLs or signed cookies, at least one AWS account (trusted signer) is needed that has an active CloudFront key pair</li>
<li>Once AWS account is added as trusted signer to the distribution, CloudFront starts to require that users use signed URLs or signed cookies to access the objects.</li>
<li>Private key from the trusted signer’s key pair to sign a portion of the URL or the cookie. When someone requests a restricted object, CloudFront compares the signed portion of the URL or cookie with the unsigned portion to verify that the URL or cookie hasn’t been tampered with. CloudFront also validates the URL or cookie is valid for e.g, that the expiration date and time hasn’t passed.</li>
<li>Each Trusted signer AWS accounts used to create CloudFront signed URLs or signed cookies must have its own active CloudFront key pair, which should be frequently rotated</li>
<li>A maximum of 5 trusted signers can be assigned for each cache behavior or RTMP distribution</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="signed-urls-vs-signed-cookies">
<h3>Signed URLs vs Signed Cookies<a class="headerlink" href="#signed-urls-vs-signed-cookies" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">CloudFront signed URLs and signed cookies helps to secure the content and provide control to decide who can access the content</p>
</li>
<li><p class="first">Use signed URLs in the following cases:</p>
<blockquote>
<div><ul class="simple">
<li>for RTMP distribution as signed cookies aren’t supported</li>
<li>to restrict access to individual files, for e.g., an installation download for your application.</li>
<li>users using a client, for e.g. a custom HTTP client, that doesn’t support cookies</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Use signed cookies in the following cases:</p>
<blockquote>
<div><ul class="simple">
<li>provide access to multiple restricted files, for e.g., all of the video files in HLS format or all of the files in the subscribers’ area of a website.</li>
<li>don’t want to change the current URLs.</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="canned-policy-vs-custom-policy">
<h3>Canned Policy vs Custom Policy<a class="headerlink" href="#canned-policy-vs-custom-policy" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Canned policy or a custom policy is a policy statement, used by the Signed URLs, helps define the restrictions for e.g. expiration date and time</li>
</ul>
<a class="reference internal image-reference" href="_images/canned_policy.png"><img alt="alternate text" class="align-center" src="_images/canned_policy.png" style="width: 650.0px; height: 450.0px;" /></a>
<ul class="simple">
<li>CloudFront validates the expiration time at the start of the event.</li>
<li>If user is downloading a large object, and the url expires the download would still continue and the same for RTMP distribution.</li>
<li>However, if the user is using range GET requests, or while streaming video skips to another position which might trigger an other event, the request would fail.</li>
</ul>
</div>
<div class="section" id="serving-compressed-files">
<h3>Serving Compressed Files<a class="headerlink" href="#serving-compressed-files" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">CloudFront can be configured to automatically compress files of certain types and serve the compressed files when viewer requests include Accept-Encoding: gzip in the request header</p>
</li>
<li><p class="first">Compressing content, downloads are faster because the files are smaller as well as less expensive as the cost of CloudFront data transfer is based on the total amount of data served</p>
</li>
<li><p class="first">If serving from a custom origin, it can be used to</p>
<blockquote>
<div><ul class="simple">
<li>configure to compress files with or without CloudFront compression</li>
<li>compress file types that CloudFront doesn’t compress.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">If the origin returns a compressed file, CloudFront detects compression by the Content-Encoding header value and doesn’t compress the file again.</p>
</li>
<li><p class="first">CloudFront serves content using compression as below</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">CloudFront distribution is created and configured to compress content.</p>
</li>
<li><p class="first">A viewer requests a compressed file by adding the Accept-Encoding: gzip header to the request.</p>
</li>
<li><p class="first">At the edge location, CloudFront checks the cache for a compressed version of the file that is referenced in the request.</p>
</li>
<li><p class="first">If the compressed file is already in the cache, CloudFront returns the file to the viewer and skips the remaining steps.</p>
</li>
<li><p class="first">If the compressed file is not in the cache, CloudFront forwards the request to the origin server (S3 bucket or a custom origin)</p>
</li>
<li><p class="first">Even if CloudFront has an uncompressed version of the file in the cache, it still forwards a request to the origin.</p>
</li>
<li><p class="first">Origin server returns an uncompressed version of the requested file</p>
</li>
<li><p class="first">CloudFront determines whether the file is compressible:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>file must be of a type that CloudFront compresses.</li>
<li>file size must be between 1,000 and 10,000,000 bytes.</li>
<li>response must include a Content-Length header for CloudFront to determine the size within valid compression limits. If the Content-Length header is missing, CloudFront won’t compress the file.</li>
<li>value of the Content-Encoding header on the file must not be gzip i.e. the origin has already compressed the file.</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">If the file is compressible, CloudFront compresses it, returns the compressed file to the viewer, and adds it to the cache.</p>
</li>
<li><p class="first">The viewer uncompresses the file.</p>
</li>
</ol>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="distribution-details">
<h2>Distribution Details<a class="headerlink" href="#distribution-details" title="Permalink to this headline">¶</a></h2>
<div class="section" id="price-class">
<h3>Price Class<a class="headerlink" href="#price-class" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">CloudFront has edge locations all over the world and as cost for each edge location varies and the price charged for serving the requests also varies</p>
</li>
<li><p class="first">CloudFront edge locations are grouped into geographic regions, and regions have been grouped into price classes</p>
<blockquote>
<div><ul class="simple">
<li>Default Price Class – includes all the regions</li>
<li>Another price class includes most regions (the United States; Europe; Hong Kong, Korea, and Singapore; Japan; and India regions) but excludes the most-expensive regions</li>
<li>A third price class includes only the least-expensive regions (the United States and Europe regions)</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Price class can be selected to lower the cost but this would come only at the expense of performance (higher latency), as CloudFront would serve requests only from the selected price class edge locations</p>
</li>
<li><p class="first">CloudFront may, sometimes, serve request from a region not included within the price class, however you would be charged the rate for the least-expensive region in your selected price class</p>
</li>
</ul>
</div>
</div>
<div class="section" id="alternate-domain-names-cnames">
<h2>Alternate Domain Names (CNAMEs)<a class="headerlink" href="#alternate-domain-names-cnames" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>CloudFront by default assigns a domain name for the distribution for e.g. d111111abcdef8.cloudfront.net</li>
<li>An alternate domain name, also known as a CNAME, can be used to use own custom domain name for links to objects</li>
<li>Both web and RTMP distributions support alternate domain names.</li>
<li>CloudFront supports * wildcard at the beginning of a domain name instead of specifying subdomains individually.</li>
<li>However, wildcard cannot replace part of a subdomain name for e.g. <em>domain.example.com, or cannot replace a subdomain in the middle of a domain name for e.g. subdomain.</em>.example.com.</li>
</ul>
</div>
<div class="section" id="geo-restriction-geoblocking">
<h2>Geo Restriction (Geoblocking)<a class="headerlink" href="#geo-restriction-geoblocking" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">Geo restriction can help allow or prevent users in selected countries from accessing the content,</p>
</li>
<li><p class="first">CloudFront distribution can be configured either to allow users in</p>
<blockquote>
<div><ul class="simple">
<li><strong>whitelist of specified countries to access the content or to</strong></li>
<li><strong>deny users in a blacklist of specified countries to access the content</strong></li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Geo restriction can be used to restrict access to all of the files that are</p>
</li>
<li><p class="first">associated with a distribution and to restrict access at the country level</p>
</li>
<li><p class="first">CloudFront responds to a request from a viewer in a restricted country with an HTTP status code 403 (Forbidden)</p>
</li>
<li><p class="first">Use a third-party geolocation service, if access is to be restricted to a subset of the files that are associated with a distribution or to restrict access at a finer granularity than the country level</p>
</li>
</ul>
</div>
<div class="section" id="cloudfront-with-amazon-s3">
<h2>CloudFront with Amazon S3<a class="headerlink" href="#cloudfront-with-amazon-s3" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">CloudFront can be used to distribute the content from an S3 bucket</p>
</li>
<li><p class="first">For an RTMP distribution, S3 bucket is the only supported origin and custom origins cannot be used</p>
</li>
<li><p class="first">Using CloudFront over S3 has the following benefits</p>
<blockquote>
<div><ul class="simple">
<li>can be more cost effective if the objects are frequently accessed as at higher usage, the price for CloudFront data transfer is much lower than the price for S3 data transfer.</li>
<li>downloads are faster with CloudFront than with S3 alone because the objects are stored closer to the users</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">When using S3 as the origin for a distribution and the bucket is moved to a different region, CloudFront can take up to an hour to update its records to include the change of region when both of the following are true:</p>
<blockquote>
<div><ul class="simple">
<li>Origin Access Identity (OAI) is used to restrict access to the bucket</li>
<li>Bucket is moved to an S3 region that requires Signature Version 4 for authentication</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="origin-access-identity">
<h2>Origin Access Identity<a class="headerlink" href="#origin-access-identity" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">With S3 as origin, objects in S3 must be granted public read permissions and hence the objects are accessible from both S3 as well as CloudFront</p>
</li>
<li><p class="first">Even though, CloudFront does not expose the underlying S3 url, it can be known to the user if shared directly or used by applications</p>
</li>
<li><p class="first">For using CloudFront signed URLs or signed cookies to provide access to the objects, it would be necessary to prevent users from having direct access to the S3 objects</p>
</li>
<li><p class="first">Users accessing S3 objects directly would</p>
<blockquote>
<div><ul class="simple">
<li>bypass the controls provided by CloudFront signed URLs or signed cookies, for e.g., control over the date time that a user can no longer access the content and the IP addresses can be used to access content</li>
<li>CloudFront access logs are less useful because they’re incomplete.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>Origin Access Identity (OAI) can be used to prevent users from directly accessing objects from S3</strong></p>
</li>
<li><p class="first">Origin access identity, which is a special CloudFront user, can be created and associated with the distribution.</p>
</li>
<li><p class="first">S3 bucket/object permissions needs to be configured to only provide access to the Origin Access Identity</p>
</li>
<li><p class="first">When users access the object from CloudFront, it uses the OAI to fetch the content on users behalf, while direct access to the S3 objects is restricted</p>
</li>
</ul>
</div>
<div class="section" id="working-with-objects">
<h2>Working with Objects<a class="headerlink" href="#working-with-objects" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">CloudFront can be configured to include custom headers or modify existing headers whenever it forwards a request to the origin, to</p>
<blockquote>
<div><ul class="simple">
<li>validate the user is not accessing the origin directly, bypassing CDN</li>
<li>identify the CDN from which the request was forwarded, if more than one CloudFront distribution is configured to use the same origin</li>
<li>if users use viewers that don’t support CORS, configure CloudFront to forward the Origin header to the origin. That will cause the origin to return the Access-Control-Allow-Origin header for every request</li>
</ul>
</div></blockquote>
</li>
</ul>
<div class="section" id="adding-updating-objects">
<h3>Adding &amp; Updating Objects<a class="headerlink" href="#adding-updating-objects" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Objects just need to be added to the Origin and CloudFront would start distributing them when accessed</p>
</li>
<li><p class="first">Objects served by CloudFront the Origin, can be updated either by</p>
<blockquote>
<div><ul class="simple">
<li>Overwriting the Original object</li>
<li>Create a different version and updating the links exposed to the user</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">For updating objects, its recommended to use versioning for e.g. have files or the entire folders with versions, so the the links can be changed when the objects are updated forcing a refresh</p>
</li>
<li><p class="first">With versioning,</p>
<blockquote>
<div><ul class="simple">
<li>there is no time wait for an object to expire before CloudFront begins to serve a new version of it</li>
<li>there is no difference in consistency in the object served from the edge</li>
<li>no cost involved to pay for object invalidation.</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="removing-invalidating-objects">
<h3>Removing/Invalidating Objects<a class="headerlink" href="#removing-invalidating-objects" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Objects, by default, would be removed upon expiry (TTL) and the latest object would be fetched from the Origin</p>
</li>
<li><p class="first">Objects can also be removed from the edge cache before it expires</p>
<blockquote>
<div><ul class="simple">
<li>Change object name (versioning) to serve a different version of the object that has a different name</li>
<li>Invalidate the object from edge caches. For the next request, CloudFront returns to the Origin to fetch the object</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">For Web distributions,</p>
<blockquote>
<div><ul>
<li><p class="first">If your objects need to be updated frequently, changing Object name (Versioning) is recommended over Invalidating objects, as it</p>
<blockquote>
<div><ul class="simple">
<li>enables to control which object a request returns even when the user has a version cached either locally or behind a corporate caching proxy. If an object is invalidated, the user might continue to see the old version until it expires from those caches.</li>
<li>makes it easier to analyze the results of object changes as CloudFront access logs include the names of the objects</li>
<li>provides a way to serve different versions to different users.</li>
<li>simplifies rolling forward &amp; back between object revisions.</li>
<li>is less expensive, as no charges for invalidating objects.</li>
<li>for e.g. change header-v1.jpg to header-v2.jpg</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Invalidating objects from the cache</p>
<blockquote>
<div><ul class="simple">
<li>objects in the cache can be invalidated explicitly before they expire to force a refresh</li>
<li>allows to invalidate selected objects</li>
<li>allows to invalidate multiple objects for e.g. objects in a directory or all of the objects whose names begin with the same characters, you can include the * wildcard at the end of the invalidation path.</li>
<li><strong>A specified number of invalidation paths can be submitted each month for free. Any invalidation requests more than the allotted no. per month, fee is charged for each submitted invalidation path</strong></li>
<li>First 1,000 invalidation paths requests submitted per month are free; charges apply for each invalidation path over 1,000 in a month.</li>
<li>Invalidation path can be for a single object for e.g. /js/ab.js or for multiple objects for e.g. /js/* and is counted as a single request even if the * wildcard request may invalidate thousands of objects</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">For RTMP distribution, objects served cannot be invalidated</p>
</li>
</ul>
</div>
<div class="section" id="partial-requests-range-gets">
<h3>Partial Requests (Range GETs)<a class="headerlink" href="#partial-requests-range-gets" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Partial requests using Range headers in a GET request helps to download the object in smaller units, improving the efficiency of partial downloads and the recovery from partially failed transfers.</p>
</li>
<li><p class="first">For a partial GET range request, CloudFront</p>
<blockquote>
<div><ul class="simple">
<li>checks the cache in the edge location for the requested range or the entire object and if exists, serves it immediately</li>
<li>if the requested range does not exist, it forwards the request to the origin and may request a larger range than the client requested to optimize performance</li>
<li>if the origin supports range header, it returns the requested object range and CloudFront returns the same to the viewer</li>
<li>if the origin does not support range header, it returns the complete object and CloudFront serves the entire object and caches it for future.</li>
<li>CloudFront uses the cached entire object to serve any future range GET header requests</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="access-logs">
<h2>Access Logs<a class="headerlink" href="#access-logs" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>CloudFront can be configured to create log files that contain detailed information about every user request that CloudFront receives.</li>
<li>Access logs are available for both web and RTMP distributions.</li>
<li>With logging enabled, an S3 bucket can be specified where CloudFront would save the files</li>
<li>CloudFront delivers access logs for a distribution periodically, up to several times an hour</li>
<li>CloudFront usually delivers the log file for that time period to the S3 bucket within an hour of the events that appear in the log. Note, however, that some or all log file entries for a time period can sometimes be delayed by up to 24 hours</li>
</ul>
</div>
<div class="section" id="cloudfront-cost">
<h2>CloudFront Cost<a class="headerlink" href="#cloudfront-cost" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">CloudFront charges are based on actual usage of the service in four areas:</p>
<blockquote>
<div><ul>
<li><p class="first">Data Transfer Out to Internet</p>
<blockquote>
<div><ul class="simple">
<li>charges are applied for the volume of data transferred out of the CloudFront edge locations, measured in GB</li>
<li>Data transfer out from AWS origin (e.g., S3, EC2, etc.) to CloudFront are no longer charged. This applies to data transfer from all AWS regions to all global CloudFront edge locations</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">HTTP/HTTPS Requests</p>
<blockquote>
<div><ul class="simple">
<li>number of HTTP/HTTPS requests made for the content</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Invalidation Requests</p>
<blockquote>
<div><ul class="simple">
<li>per path in the invalidation request</li>
<li>A path listed in the invalidation request represents the URL (or multiple URLs if the path contains a wildcard character) of the object you want to invalidate from CloudFront cache</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Dedicated IP Custom SSL certificates associated with a CloudFront distribution</p>
<blockquote>
<div><ul class="simple">
<li>$600 per month for each custom SSL certificate associated with one or more CloudFront distributions using the Dedicated IP version of custom SSL certificate support, pro-rated by the hour</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">AWS CloudFront</a><ul>
<li><a class="reference internal" href="#cloudfront-benefits">CloudFront Benefits</a></li>
<li><a class="reference internal" href="#configuration-content-delivery">Configuration &amp; Content Delivery</a></li>
<li><a class="reference internal" href="#delivery-methods">Delivery Methods</a><ul>
<li><a class="reference internal" href="#web-distributions">Web distributions</a></li>
<li><a class="reference internal" href="#rmtp-distributions">RMTP distributions</a></li>
<li><a class="reference internal" href="#origin">Origin</a></li>
<li><a class="reference internal" href="#cache-behavior">Cache Behavior</a></li>
<li><a class="reference internal" href="#viewer-protocol-policy">Viewer Protocol Policy</a></li>
<li><a class="reference internal" href="#https-connection">HTTPS Connection</a></li>
<li><a class="reference internal" href="#allowed-http-methods">Allowed HTTP methods</a></li>
<li><a class="reference internal" href="#improving-cloudfront-edge-caches">Improving CloudFront Edge Caches</a></li>
<li><a class="reference internal" href="#object-caching-expiration">Object Caching &amp; Expiration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#restrict-viewer-access">Restrict viewer access</a><ul>
<li><a class="reference internal" href="#serving-private-content">Serving Private Content</a></li>
<li><a class="reference internal" href="#signed-urls-vs-signed-cookies">Signed URLs vs Signed Cookies</a></li>
<li><a class="reference internal" href="#canned-policy-vs-custom-policy">Canned Policy vs Custom Policy</a></li>
<li><a class="reference internal" href="#serving-compressed-files">Serving Compressed Files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#distribution-details">Distribution Details</a><ul>
<li><a class="reference internal" href="#price-class">Price Class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternate-domain-names-cnames">Alternate Domain Names (CNAMEs)</a></li>
<li><a class="reference internal" href="#geo-restriction-geoblocking">Geo Restriction (Geoblocking)</a></li>
<li><a class="reference internal" href="#cloudfront-with-amazon-s3">CloudFront with Amazon S3</a></li>
<li><a class="reference internal" href="#origin-access-identity">Origin Access Identity</a></li>
<li><a class="reference internal" href="#working-with-objects">Working with Objects</a><ul>
<li><a class="reference internal" href="#adding-updating-objects">Adding &amp; Updating Objects</a></li>
<li><a class="reference internal" href="#removing-invalidating-objects">Removing/Invalidating Objects</a></li>
<li><a class="reference internal" href="#partial-requests-range-gets">Partial Requests (Range GETs)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#access-logs">Access Logs</a></li>
<li><a class="reference internal" href="#cloudfront-cost">CloudFront Cost</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="aws_ebs_vs_instance_store.html"
                        title="previous chapter">AWS EBS vs Instance Store</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/aws_cloudfront.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="aws_ebs_vs_instance_store.html" title="AWS EBS vs Instance Store"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">KX 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="aws.html" >Amazon Web Services</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Kevin X.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>